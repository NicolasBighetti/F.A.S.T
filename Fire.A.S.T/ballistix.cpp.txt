#include <iostream>
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include <math.h>

using namespace cv;
using namespace std;

double precisionToCenter(Point* topLeft, Point* topRight, Point* botRight, Point* impact, Mat& imgOriginal);
Point* detectObject(Mat& imgThresholded);
void cross(Mat& img, int posX, int posY, Scalar color);


void cross(Mat& img, int posX, int posY, Scalar color){
	line(img, Point(posX-10, posY), Point(posX+10, posY), color, 1);
   line(img, Point(posX, posY-10), Point(posX, posY+10), color, 1);
}

//Answer in percent, relative to the distance between the two top target dots
double precisionToCenter(Point* topLeft, Point* topRight, Point* botRight, Point* impact, Mat& imgOriginal){
	
	int centerX = ((*topLeft).x+(*botRight).x)/2;
	int centerY = ((*topLeft).y+(*botRight).y)/2;
	cross(imgOriginal, centerX, centerY, Scalar(255, 255, 255));

	//cout << ((*topLeft).x-(*topRight).x) << " <--ICI" << endl;	
	
	double distBetweenTopDots = sqrt( ((*topLeft).x-(*topRight).x)*((*topLeft).x-(*topRight).x)  +  ((*topLeft).y-(*topRight).y)*((*topLeft).y-(*topRight).y) );
	
	double distBetweenTargetAndCenter = sqrt( ((centerX-(*impact).x)*(centerX-(*impact).x)) + ((centerY-(*impact).y)*(centerY-(*impact).y)) );

	double accuracy = 100-(distBetweenTargetAndCenter/distBetweenTopDots)*100;
	
	if (accuracy < 0){
		accuracy = 0;	
	}
	return accuracy;

}


//Detect a single object
 	Point* detectObject(Mat& imgThresholded){
		
		int posX = -1;
   	int posY = -1;    		
		
		//Calculate the moments of the thresholded image
  		Moments oMoments = moments(imgThresholded);

   	double dM01 = oMoments.m01;
  		double dM10 = oMoments.m10;
  		double dArea = oMoments.m00;

   	// if the area <= 10000, I consider that the there are no object in the image and it's because of the noise, the area is not zero 
  		if (dArea > 10000)
  		{
   		//calculate the position of the ball
   		posX = dM10 / dArea;
   		posY = dM01 / dArea;        
		}

   	imshow("Thresholded Image", imgThresholded); //show the thresholded image
   	return new Point(posX, posY);
	}



int main( int argc, char** argv )
{
   VideoCapture cap(0); //capture the video from webcam

   if ( !cap.isOpened() )  // if not success, exit program
   {
      cout << "Cannot open the web cam" << endl;
		return -1;
 	}

	//-------------------------------------------------------------------------------------------------- HSV range for object detection
   namedWindow("Control", CV_WINDOW_AUTOSIZE); //create a window called "Control"

	int iLowH = 46;
	int iHighH = 76;

  	int iLowS = 60; 
 	int iHighS = 255;

  	int iLowV = 65;
 	int iHighV = 161;

  	//Create trackbars in "Control" window
 	createTrackbar("LowH", "Control", &iLowH, 179); //Hue (0 - 179)
 	createTrackbar("HighH", "Control", &iHighH, 179);

  	createTrackbar("LowS", "Control", &iLowS, 255); //Saturation (0 - 255)
 	createTrackbar("HighS", "Control", &iHighS, 255);

 	createTrackbar("LowV", "Control", &iLowV, 255);//Value (0 - 255)
 	createTrackbar("HighV", "Control", &iHighV, 255);


	//-------------------------------------------------------------------------------------------------- HSV range for target detection
	namedWindow("ControlTarget", CV_WINDOW_AUTOSIZE); //create a window called "Control"
	
	int targetLowH = 139;
	int targetHighH = 179;

  	int targetLowS = 89; 
 	int targetHighS = 243;

  	int targetLowV = 44;
 	int targetHighV = 155;

  	//Create trackbars in "Control" window
 	createTrackbar("LowH", "ControlTarget", &targetLowH, 179); //Hue (0 - 179)
 	createTrackbar("HighH", "ControlTarget", &targetHighH, 179);

  	createTrackbar("LowS", "ControlTarget", &targetLowS, 255); //Saturation (0 - 255)
 	createTrackbar("HighS", "ControlTarget", &targetHighS, 255);

 	createTrackbar("LowV", "ControlTarget", &targetLowV, 255);//Value (0 - 255)
 	createTrackbar("HighV", "ControlTarget", &targetHighV, 255);
 	
 	bool isConfirmed = false;	//When the coordinates are almost correct, locks them by setting to true
 	Point* topLeft = new Point(-1, -1);
 	Point* topRight = new Point(-1, -1);
 	Point* botRight = new Point(-1, -1);

	//-------------------------------------------------------------------------------------------------- Rest of the code

  	//Capture a temporary image from the camera
 	Mat imgTmp;
 	cap.read(imgTmp);
 	
  	while (true)
   {
		Mat imgOriginal;

     	bool bSuccess = cap.read(imgOriginal); // read a new frame from video
      if (!bSuccess) //if not success, break loop
      {
      	cout << "Cannot read a frame from video stream" << endl;
         break;
      }

		Mat imgHSV;
   	cvtColor(imgOriginal, imgHSV, COLOR_BGR2HSV); //Convert the captured frame from BGR to HSV
 
 		//Target detection
		if (isConfirmed == false){
  			Mat imgTargetThresholded;
   		inRange(imgHSV, Scalar(targetLowH, targetLowS, targetLowV), Scalar(targetHighH, targetHighS, targetHighV), imgTargetThresholded); //Threshold the image
      
  			//morphological opening (removes small objects from the foreground)
  			erode(imgTargetThresholded, imgTargetThresholded, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)) );
  			dilate(imgTargetThresholded, imgTargetThresholded, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)) ); 

   		//morphological closing (removes small holes from the foreground)
  			dilate(imgTargetThresholded, imgTargetThresholded, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)) ); 
  			erode(imgTargetThresholded, imgTargetThresholded, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)) );
  			
  			imshow("Target Threshold", imgTargetThresholded); //show the original image
  			
  			int middleX = (imgTargetThresholded.size().width)/2;
  			int middleY = (imgTargetThresholded.size().height)/2;
  			
			Mat cropTopLeft = imgTargetThresholded.clone();
			Mat cropTopRight = imgTargetThresholded.clone();
			Mat cropBotRight = imgTargetThresholded.clone();
  			
			Rect topLeftROI(0, 0, middleX, middleY);
			Rect topRightROI(middleX, 0, middleX, middleY);
			Rect botRightROI(middleX, middleY, middleX, middleY);
			
			// Crop the full image /!\ This doesn't copy the data!
			cropTopLeft = cropTopLeft(topLeftROI);
			cropTopRight = cropTopRight(topRightROI);
			cropBotRight = cropBotRight(botRightROI);
  			
  			topLeft = detectObject(cropTopLeft);
  			topRight = detectObject(cropTopRight);
  			botRight = detectObject(cropBotRight);
  			
  			//From relative position in the cropped images to position in the entire image
  			(*topRight).x += middleX;
  			(*botRight).x += middleX;
  			(*botRight).y += middleY;
  			
  			rectangle(imgOriginal, topLeftROI, Scalar(200,200,200));
  			rectangle(imgOriginal, topRightROI, Scalar(0,200,200));
  			rectangle(imgOriginal, botRightROI, Scalar(200,200,200));
		} 		 		
 		
 		
 		//Object detection
  		Mat imgThresholded;
   	inRange(imgHSV, Scalar(iLowH, iLowS, iLowV), Scalar(iHighH, iHighS, iHighV), imgThresholded); //Threshold the image
      
  		//morphological opening (removes small objects from the foreground)
  		erode(imgThresholded, imgThresholded, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)) );
  		dilate(imgThresholded, imgThresholded, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)) ); 

   	//morphological closing (removes small holes from the foreground)
  		dilate(imgThresholded, imgThresholded, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)) ); 
  		erode(imgThresholded, imgThresholded, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)) );
		
   	Point* target = detectObject(imgThresholded);
   	if ((*target).x >= 0 && (*target).y >= 0){
   		cross(imgOriginal, (*target).x, (*target).y, Scalar(0,0,255));
			double precisionPercentage = precisionToCenter(topLeft, topRight, botRight, target, imgOriginal);
   		cout << "X: " << (*target).x << "  -  Y: " << (*target).y << "  -  Precision: " << precisionPercentage << "%" << endl;
		}

    	
    	if ( (*topLeft).x >= 0 && (*topLeft).y >= 0){
			cross(imgOriginal, (*topLeft).x, (*topLeft).y, Scalar(0, 0, 255));
    	}
    	if ( (*topRight).x >= 0 && (*topRight).y >= 0){
			cross(imgOriginal, (*topRight).x, (*topRight).y, Scalar(0, 0, 255));
    	}
    	if ( (*botRight).x >= 0 && (*botRight).y >= 0){
			cross(imgOriginal, (*botRight).x, (*botRight).y, Scalar(0, 0, 255));
    	}
   	
  		imshow("Original", imgOriginal); //show the original image

   	if (waitKey(15) == 27) //wait for 'esc' key press for 30ms. If 'esc' key is pressed, break loop
   	{
   		cout << "esc key is pressed by user" << endl;
      	break; 
   	}
   	
   	//wait for 'esc' key press for 30ms. If 'esc' key is pressed, break loop
   	if ( (waitKey(15) == 32) && (*topLeft).x >= 0 && (*topLeft).y >= 0 && (*topRight).x >= 0 && (*topRight).y >= 0 && (*botRight).x >= 0 && (*botRight).y >= 0)
   	{
   		cout << "space key is pressed by user" << endl;
			if (isConfirmed){
				isConfirmed = false;
			}    		
   		else{
				isConfirmed = true;   		
   		}
   	}
	}

   return 0;
}
